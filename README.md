你好。我叫XX。之前在上海微创BPO部门做过三年Java开发。

1、开发中Java用了比较多的数据结构有哪些？（待补充arraylist,treemap）
ArrayList。HashMap。

HashTable和HashMap区别
1、继承的父类不同
Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。
2、线程安全性不同
Hashtable 中的方法是Synchronize的，而HashMap中的方法在是非Synchronize的。
3、是否提供contains方法
HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。
4、key和value是否允许null值
5、两个遍历方式的内部实现上不同
Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。
6、hash值不同
哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
7、内部实现使用的数组初始化和扩容方式不同
HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。
Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。

2、谈谈你对HashMap的理解，底层原理的基本实现，HashMap怎么解决碰撞问题的？
HashMap是数组+链表的结构。JDK8中，当链表的长度达到8时，链表会转成红黑树。通过红黑树快速增删改查的特点提高HashMap的性能。
第一次put操作时开辟一个16容量的哈希桶数组。每个元素是一个Entry对象。包含key,value,next,hash四个属性。
通过对key的hash算法确定entry元素的位置。hash算法的三个步骤：取key的hashCode值，位移异或，按位与运算。默认初始容量为16是为了符合Hash算法均匀分布原则。
key是null，放在0下标位置。如果没有碰撞，直接放在对应下标位置。如果碰撞了，看key是否相同，相同则覆盖value。不同则往链表头上插入元素，因为作者认为后插入的有更大概率被搜索。
此时如果元素个数达到数组容量*0.75负载因子时，数组会扩容为原来两倍。所有元素重新hash确定下标位置。频繁扩容会影响性能。所以《阿里巴巴开发手册》规定hashmap初始化时要指定大小。在多线程情况下同时rehash有可能会出现带环链表。所以高并发情况下使用concurrentHashmap。concurrenthashmap有2的n次方个segment。通过锁分段技术，每个segment高度自治，相互独立，降低锁的粒度。由此兼顾性能与安全。

3、What is an efficient way to implement a singleton pattern in Java?
```
public enum SingletonEnum {
    INSTANCE;
}
```
枚举的线程安全，底层已经做了保证。
枚举中的枚举项是通过static定义的。
当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个enum类型是线程安全的。

4、对JVM熟不熟悉？简单说说类加载过程，里面执行的那些操作？问了GC和内存管理，平时在tomcat里面有没有进行相关的配置。
类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。
加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不确定，是为了支持Java语言的运行时绑定。
加载：通过类的全限定名取得类的二进制流，转为方法区数据结构，在Java堆中生成对应的Class对象，作为对方法区这些数据的访问入口。
验证：文件格式、元数据、字节码、符号引用验证。
准备：类变量分配内存并设置类变量初始值。
解析：符号引用替换为直接引用，类或接口的解析，字段解析，类方法解析，接口方法解析。
初始化：若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。

双亲委派机制
要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里父子关系是组合关系。
如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。
好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载。

如何判断对象死亡？
两种方法。引用计数法（给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。）。
可达性分析算法。




5、然后问了http协议，get和post的基本区别，接着tcp/ip协议，三次握手，窗口滑动机制。
HTTP用于客户端和服务端之间的通信，请求资源的一端为客户端，而提供响应资源的一端为服务端。
客户端请求的内容包括：请求方法、URI、协议版本、请求头部字段、请求主体。

GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息
GET是幂等的，因为不会修改数据。POST不是幂等的。
GET参数通过URL传递，POST放在Request body中。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET请求在URL中传送的参数是有长度限制的，而POST没有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET请求只能进行url编码，而POST支持多种编码方式。
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被收藏为书签，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

TCP/IP协议是一个协议集合。包含HTTP、FTP、TCP、IP、DNS、UDP等。
TCP/IP协议的分层管理：应用层、传输层、网络层、链路层。及通信传输流。

TCP用三次握手和滑动窗口机制来保证传输的可靠性和进行流量控制。
第一次握手:
客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。
第二次握手:
服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN加1以.即X+1。
第三次握手.
客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1



TCP四次挥手：（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。       
（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。       
（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。       
（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。






滑动窗口算法？

1. 首先是AB之间三次握手建立TCP连接。在报文的交互过程中，A将自己的缓冲区大小（窗口大小）3发送给B，B同理，这样双方就知道了对端的窗口大小。
2. A开始发送数据，A连续发送3个单位的数据，因为他知道B的缓冲区大小。在这一波数据发送完后，A就不能再发了，需等待B的确认。
3. A发送过来的数据逐渐将缓冲区填满。
4. 这时候缓冲区中的一个报文被进程读取，缓冲区有了一个空位，于是B向A发送一个ACK，这个报文中指示窗口大小为1。
A收到B发过来的ACK消息，并且知道B将窗口大小调整为1，因此他只发送了一个单位的数据并且等待B的下一个确认报文。
5. 如此反复。



6、开发中用了那些数据库？回答mysql，存储引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。
1. MyIsam , 2. InnoDB, 3. Memory, 4. Blackhole, 5. CSV, 6. Performance_Schema, 7. Archive, 8. Federated , 9 Mrg_Myisam

乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

分布式系统的CAP理论：  一致性、可用性、分区容错性。


7、然后问了我springmvc和mybatis的工作原理，有没有看过底层源码？
https://www.zhihu.com/question/21346206/answer/391667981

8、redis存储类型、事务、使用场景。

二、京东金融面试

1、Dubbo超时重试；Dubbo超时时间设置

2、如何保障请求执行顺序

3、分布式事物与分布式锁（扣款不要出现负数）

4、分布式session设置

5、执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）

6、Zookeeper有哪些用

7、JVM内存模型

8、数据库垂直和水平拆分

9、MyBatis如何分页；如何设置缓存；MySQL分页

10、熟悉IO么？与NIO的区别，阻塞与非阻塞的区别

11、分布式session一致性

12、分布式接口的幂等性设计「不能重复扣款」

三、美团面试

1、最近做的比较熟悉的项目是哪个？画一下项目技术架构图

2、JVM老年代和新生代的比例？

3、YGC和FGC发生的具体场景

4、jstack，jmap，jutil分别的意义？如何线上排查JVM的相关问题？

5、线程池的构造类的方法的5个参数的具体意义？

6、单机上一个线程池正在处理服务如果忽然断电该怎么办？（正在处理和阻塞队列里的请求怎么处理）？

7、使用无界阻塞队列会出现什么问题？

8、接口如何处理重复请求？

9、具体处理方案是什么？

10、如何保证共享变量修改时的原子性？

11、设计一个对外服务的接口实现类，在1,2,3这三个主机（对应不同IP）上实现负载均衡和顺序轮询机制（考虑并发）


四、滴滴面试

1、自我介绍，技术特点

2、兴趣是什么，优势是什么

3、jvm，jre以及jdk三者之间的关系？

4、Dubbo的底层原理，Zookeeper是什么

5、cincurrentMap的机制；TreeMap；Volatil关键字

6、快速排序；广度优先搜索（队列实现）

7、缓存的雪崩以及穿透的理解？

8、HashMap的key可以重复吗？

9、synchronized和lock的区别？

10.开发一个大型网站你会考虑哪些问题?
